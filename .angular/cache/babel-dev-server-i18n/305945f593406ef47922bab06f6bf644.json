{"ast":null,"code":"import { HttpResponse } from '@angular/common/http';\nimport { BehaviorSubject, throwError, timer } from 'rxjs';\nimport { catchError, filter, finalize, mergeMap, retryWhen, switchMap, take, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./authenticate.service\";\nimport * as i2 from \"./loading-service.service\";\nexport class HttpInterceptorService {\n  constructor(authenticateService, loadingService) {\n    this.authenticateService = authenticateService;\n    this.loadingService = loadingService;\n    this.totalRequests = 0;\n    this.refreshTokenSubject = new BehaviorSubject(null);\n    this.refreshTokenInProgress = false;\n  }\n\n  intercept(req, next) {\n    let params = req.params;\n\n    for (const key of req.params.keys()) {\n      if (params.get(key) === 'undefined' || params.get(key) === 'null') {\n        params = params.delete(key);\n      }\n    }\n\n    req = req.clone({\n      params\n    });\n\n    if (this.authenticateService.isLoggedIn) {\n      req = req.clone({\n        setHeaders: {\n          Authorization: this.authenticateService.currentTokenValue\n        }\n      });\n    } else if (req.url.includes('authenticate')) {} else {\n      return this.authenticateService.waitInit().pipe(filter(result => result !== null), take(1), switchMap(result => {\n        req = req.clone({\n          setHeaders: {\n            Authorization: this.authenticateService.currentTokenValue\n          }\n        });\n        return this.handleIntercept(req, next);\n      }));\n    }\n\n    return this.handleIntercept(req, next);\n  }\n\n  handleIntercept(req, next) {\n    var timer;\n\n    if (req.method !== 'GET') {\n      this.totalRequests++;\n      timer = setTimeout(() => this.loadingService.visibility.next(true), 1000);\n    }\n\n    const startTimestamp2 = new Date().getTime();\n    return next.handle(req).pipe(tap(event => {\n      if (event instanceof HttpResponse) {\n        const endTimestamp = new Date().getTime();\n        console.log(endTimestamp - startTimestamp2 + '    ' + event.url);\n        console.log(event.body);\n      }\n\n      return event;\n    }), retryWhen(genericRetryStrategy({\n      scalingDuration: 500,\n      excludedStatusCodes: [400]\n    })), catchError(error => {\n      if (error.status === 401) {\n        return this.handle401Error(req, next);\n      }\n\n      let errorMessage = '';\n\n      if (error.error instanceof ErrorEvent) {\n        // client-side error\n        errorMessage = `Error: ${error.error.message}`;\n      } else {\n        // server-side error\n        errorMessage = `Error Code: ${error.status}\\nMessage: ${error.error}`;\n      }\n\n      console.log(error);\n      window.alert(errorMessage);\n      return throwError(errorMessage);\n    }), finalize(() => {\n      if (req.method !== 'GET') {\n        this.totalRequests--;\n\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        if (this.totalRequests === 0) {\n          this.loadingService.visibility.next(false);\n        }\n      }\n    }));\n  }\n\n  handle401Error(req, next) {\n    if (req.url.includes('authenticate')) {\n      this.authenticateService.logOut();\n      window.alert(\"Incorrect username or password you are redirected to login\");\n      return throwError('');\n    }\n\n    if (this.refreshTokenInProgress) {\n      // If refreshTokenInProgress is true, we will wait until refreshTokenSubject has a non-null value\n      // – which means the new token is ready and we can retry the request again\n      return this.refreshTokenSubject.pipe(filter(result => result !== null), take(1), switchMap(result => {\n        req = req.clone({\n          setHeaders: {\n            Authorization: this.authenticateService.currentTokenValue\n          }\n        });\n        return this.handleIntercept(req, next);\n      }));\n    } else if (sessionStorage.getItem('username')) {\n      this.refreshTokenInProgress = true;\n      this.refreshTokenSubject.next(null);\n      this.authenticateService.refreshToken();\n      var person = prompt(\"Please enter your password again\", \"\");\n      return this.authenticateService.authenticate(sessionStorage.getItem('username'), person).pipe(switchMap(token => {\n        this.refreshTokenInProgress = false;\n        this.refreshTokenSubject.next(token);\n        req = req.clone({\n          setHeaders: {\n            Authorization: this.authenticateService.currentTokenValue\n          }\n        });\n        return this.handleIntercept(req, next);\n      }), catchError(error => {\n        this.authenticateService.logOut();\n        window.alert(\"Incorrect username or password you are redirected to login\");\n        return throwError('');\n      }));\n    } else {\n      this.authenticateService.logOut();\n      window.alert(\"Incorrect username or password you are redirected to login\");\n      return throwError('');\n    }\n  }\n\n}\n\nHttpInterceptorService.ɵfac = function HttpInterceptorService_Factory(t) {\n  return new (t || HttpInterceptorService)(i0.ɵɵinject(i1.AuthenticateService), i0.ɵɵinject(i2.LoadingService));\n};\n\nHttpInterceptorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: HttpInterceptorService,\n  factory: HttpInterceptorService.ɵfac,\n  providedIn: 'root'\n});\nexport const genericRetryStrategy = ({\n  maxRetryAttempts = 3,\n  scalingDuration = 1000,\n  excludedStatusCodes = []\n} = {}) => attempts => {\n  return attempts.pipe(mergeMap((error, i) => {\n    const retryAttempt = i + 1; // if maximum number of retries have been met\n    // or response is a status code we don't wish to retry, throw error\n\n    if (retryAttempt > maxRetryAttempts || excludedStatusCodes.find(e => error.status >= e && error.status <= e + 100)) {\n      return throwError(error);\n    }\n\n    console.log(`Attempt ${retryAttempt}: retrying in ${retryAttempt * scalingDuration}ms`); // retry after 1s, 2s, etc...\n\n    return timer(retryAttempt * scalingDuration);\n  }), finalize(() => console.log('We are done!')));\n};","map":{"version":3,"sources":["C:/Users/isral/OneDrive/Documents/AVC-FRONT/src/app/service/http-interceptor.service.ts"],"names":["HttpResponse","BehaviorSubject","throwError","timer","catchError","filter","finalize","mergeMap","retryWhen","switchMap","take","tap","i0","i1","i2","HttpInterceptorService","constructor","authenticateService","loadingService","totalRequests","refreshTokenSubject","refreshTokenInProgress","intercept","req","next","params","key","keys","get","delete","clone","isLoggedIn","setHeaders","Authorization","currentTokenValue","url","includes","waitInit","pipe","result","handleIntercept","method","setTimeout","visibility","startTimestamp2","Date","getTime","handle","event","endTimestamp","console","log","body","genericRetryStrategy","scalingDuration","excludedStatusCodes","error","status","handle401Error","errorMessage","ErrorEvent","message","window","alert","clearTimeout","logOut","sessionStorage","getItem","refreshToken","person","prompt","authenticate","token","ɵfac","HttpInterceptorService_Factory","t","ɵɵinject","AuthenticateService","LoadingService","ɵprov","ɵɵdefineInjectable","factory","providedIn","maxRetryAttempts","attempts","i","retryAttempt","find","e"],"mappings":"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","sourcesContent":["import { HttpResponse } from '@angular/common/http';\r\nimport { BehaviorSubject, throwError, timer } from 'rxjs';\r\nimport { catchError, filter, finalize, mergeMap, retryWhen, switchMap, take, tap } from 'rxjs/operators';\r\nimport * as i0 from \"@angular/core\";\r\nimport * as i1 from \"./authenticate.service\";\r\nimport * as i2 from \"./loading-service.service\";\r\nexport class HttpInterceptorService {\r\n    constructor(authenticateService, loadingService) {\r\n        this.authenticateService = authenticateService;\r\n        this.loadingService = loadingService;\r\n        this.totalRequests = 0;\r\n        this.refreshTokenSubject = new BehaviorSubject(null);\r\n        this.refreshTokenInProgress = false;\r\n    }\r\n    intercept(req, next) {\r\n        let params = req.params;\r\n        for (const key of req.params.keys()) {\r\n            if (params.get(key) === 'undefined' || params.get(key) === 'null') {\r\n                params = params.delete(key);\r\n            }\r\n        }\r\n        req = req.clone({ params });\r\n        if (this.authenticateService.isLoggedIn) {\r\n            req = req.clone({\r\n                setHeaders: {\r\n                    Authorization: this.authenticateService.currentTokenValue\r\n                }\r\n            });\r\n        }\r\n        else if (req.url.includes('authenticate')) {\r\n        }\r\n        else {\r\n            return this.authenticateService.waitInit().pipe(filter(result => result !== null), take(1), switchMap((result) => {\r\n                req = req.clone({\r\n                    setHeaders: {\r\n                        Authorization: this.authenticateService.currentTokenValue\r\n                    }\r\n                });\r\n                return this.handleIntercept(req, next);\r\n            }));\r\n        }\r\n        return this.handleIntercept(req, next);\r\n    }\r\n    handleIntercept(req, next) {\r\n        var timer;\r\n        if (req.method !== 'GET') {\r\n            this.totalRequests++;\r\n            timer = setTimeout(() => this.loadingService.visibility.next(true), 1000);\r\n        }\r\n        const startTimestamp2 = new Date().getTime();\r\n        return next.handle(req).pipe(tap((event) => {\r\n            if (event instanceof HttpResponse) {\r\n                const endTimestamp = new Date().getTime();\r\n                console.log(endTimestamp - startTimestamp2 + '    ' + event.url);\r\n                console.log(event.body);\r\n            }\r\n            return event;\r\n        }), retryWhen(genericRetryStrategy({\r\n            scalingDuration: 500,\r\n            excludedStatusCodes: [400]\r\n        })), catchError((error) => {\r\n            if (error.status === 401) {\r\n                return this.handle401Error(req, next);\r\n            }\r\n            let errorMessage = '';\r\n            if (error.error instanceof ErrorEvent) {\r\n                // client-side error\r\n                errorMessage = `Error: ${error.error.message}`;\r\n            }\r\n            else {\r\n                // server-side error\r\n                errorMessage = `Error Code: ${error.status}\\nMessage: ${error.error}`;\r\n            }\r\n            console.log(error);\r\n            window.alert(errorMessage);\r\n            return throwError(errorMessage);\r\n        }), finalize(() => {\r\n            if (req.method !== 'GET') {\r\n                this.totalRequests--;\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                }\r\n                if (this.totalRequests === 0) {\r\n                    this.loadingService.visibility.next(false);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n    handle401Error(req, next) {\r\n        if (req.url.includes('authenticate')) {\r\n            this.authenticateService.logOut();\r\n            window.alert($localize `Incorrect username or password you are redirected to login`);\r\n            return throwError('');\r\n        }\r\n        if (this.refreshTokenInProgress) {\r\n            // If refreshTokenInProgress is true, we will wait until refreshTokenSubject has a non-null value\r\n            // – which means the new token is ready and we can retry the request again\r\n            return this.refreshTokenSubject.pipe(filter(result => result !== null), take(1), switchMap((result) => {\r\n                req = req.clone({\r\n                    setHeaders: {\r\n                        Authorization: this.authenticateService.currentTokenValue\r\n                    }\r\n                });\r\n                return this.handleIntercept(req, next);\r\n            }));\r\n        }\r\n        else if (sessionStorage.getItem('username')) {\r\n            this.refreshTokenInProgress = true;\r\n            this.refreshTokenSubject.next(null);\r\n            this.authenticateService.refreshToken();\r\n            var person = prompt($localize `Please enter your password again`, \"\");\r\n            return this.authenticateService.authenticate(sessionStorage.getItem('username'), person).pipe(switchMap((token) => {\r\n                this.refreshTokenInProgress = false;\r\n                this.refreshTokenSubject.next(token);\r\n                req = req.clone({\r\n                    setHeaders: {\r\n                        Authorization: this.authenticateService.currentTokenValue\r\n                    }\r\n                });\r\n                return this.handleIntercept(req, next);\r\n            }), catchError((error) => {\r\n                this.authenticateService.logOut();\r\n                window.alert($localize `Incorrect username or password you are redirected to login`);\r\n                return throwError('');\r\n            }));\r\n        }\r\n        else {\r\n            this.authenticateService.logOut();\r\n            window.alert($localize `Incorrect username or password you are redirected to login`);\r\n            return throwError('');\r\n        }\r\n    }\r\n}\r\nHttpInterceptorService.ɵfac = function HttpInterceptorService_Factory(t) { return new (t || HttpInterceptorService)(i0.ɵɵinject(i1.AuthenticateService), i0.ɵɵinject(i2.LoadingService)); };\r\nHttpInterceptorService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: HttpInterceptorService, factory: HttpInterceptorService.ɵfac, providedIn: 'root' });\r\nexport const genericRetryStrategy = ({ maxRetryAttempts = 3, scalingDuration = 1000, excludedStatusCodes = [] } = {}) => (attempts) => {\r\n    return attempts.pipe(mergeMap((error, i) => {\r\n        const retryAttempt = i + 1;\r\n        // if maximum number of retries have been met\r\n        // or response is a status code we don't wish to retry, throw error\r\n        if (retryAttempt > maxRetryAttempts ||\r\n            excludedStatusCodes.find(e => error.status >= e && error.status <= e + 100)) {\r\n            return throwError(error);\r\n        }\r\n        console.log(`Attempt ${retryAttempt}: retrying in ${retryAttempt *\r\n            scalingDuration}ms`);\r\n        // retry after 1s, 2s, etc...\r\n        return timer(retryAttempt * scalingDuration);\r\n    }), finalize(() => console.log('We are done!')));\r\n};\r\n"]},"metadata":{},"sourceType":"module"}